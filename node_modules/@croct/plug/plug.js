"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalPlug = void 0;
var tslib_1 = require("tslib");
var sdkFacade_1 = require("@croct/sdk/facade/sdkFacade");
var error_1 = require("@croct/sdk/error");
var validation_1 = require("@croct/sdk/validation");
var token_1 = require("@croct/sdk/token");
var sdk_1 = require("@croct/sdk");
var constants_1 = require("./constants");
var playground_1 = require("./playground");
var PLUGIN_NAMESPACE = 'Plugin';
function detectAppId() {
    var script = window.document.querySelector("script[src^='" + constants_1.CDN_URL + "']");
    if (!(script instanceof HTMLScriptElement)) {
        return null;
    }
    return (new URL(script.src)).searchParams.get('appId');
}
var GlobalPlug = /** @class */ (function () {
    function GlobalPlug() {
        var _this = this;
        this.pluginFactories = { playground: playground_1.factory };
        this.plugins = {};
        this.ready = new Promise(function (resolve) {
            _this.initialize = resolve;
        });
    }
    GlobalPlug.prototype.extend = function (name, plugin) {
        if (this.pluginFactories[name] !== undefined) {
            throw new Error("Another plugin is already registered with name \"" + name + "\".");
        }
        this.pluginFactories[name] = plugin;
    };
    GlobalPlug.prototype.plug = function (configuration) {
        var e_1, _a;
        var _this = this;
        var _b, _c, _d, _e;
        if (configuration === void 0) { configuration = {}; }
        if (this.instance !== undefined) {
            var logger_1 = this.instance.getLogger();
            logger_1.info('Croct is already plugged in.');
            return;
        }
        var detectedAppId = detectAppId();
        var configuredAppId = (_b = configuration.appId) !== null && _b !== void 0 ? _b : null;
        if (detectedAppId !== null && configuredAppId !== null && detectedAppId !== configuredAppId) {
            throw new Error('The specified app ID and the auto-detected app ID are conflicting. '
                + 'There is no need to specify an app ID when using an application-specific tag. '
                + 'Please try again omitting the "appId" option.');
        }
        var appId = detectedAppId !== null && detectedAppId !== void 0 ? detectedAppId : configuredAppId;
        if (appId === null) {
            throw new Error('The app ID must be specified when it cannot be auto-detected. '
                + 'Please try again specifying the "appId" option.');
        }
        var plugins = configuration.plugins, test = configuration.test, sdkConfiguration = tslib_1.__rest(configuration, ["plugins", "test"]);
        var sdk = sdkFacade_1.SdkFacade.init(tslib_1.__assign(tslib_1.__assign({}, sdkConfiguration), { appId: appId, test: test !== null && test !== void 0 ? test : (typeof process === 'object' && (((_c = process.env) === null || _c === void 0 ? void 0 : _c.CROCT_TEST_MODE) !== undefined
                ? process.env.CROCT_TEST_MODE === 'true'
                : ((_d = process.env) === null || _d === void 0 ? void 0 : _d.NODE_ENV) === 'test')) }));
        this.instance = sdk;
        var logger = this.instance.getLogger();
        if (detectedAppId === configuredAppId) {
            logger.warn('It is strongly recommended omitting the "appId" option when using '
                + 'the application-specific tag as it is detected automatically.');
        }
        var pending = [];
        var _loop_1 = function (name_1, options) {
            logger.debug("Initializing plugin \"" + name_1 + "\"...");
            var factory = this_1.pluginFactories[name_1];
            if (factory === undefined) {
                logger.error("Plugin \"" + name_1 + "\" is not registered.");
                return "continue";
            }
            if (typeof options !== 'boolean' && (options === null || typeof options !== 'object')) {
                logger.error("Invalid options for plugin \"" + name_1 + "\", "
                    + ("expected either boolean or object but got " + validation_1.describe(options)));
                return "continue";
            }
            if (options === false) {
                logger.warn("Plugin \"" + name_1 + "\" is declared but not enabled");
                return "continue";
            }
            var args = {
                options: options === true ? {} : options,
                sdk: {
                    version: sdk_1.VERSION,
                    appId: appId,
                    tracker: sdk.tracker,
                    evaluator: sdk.evaluator,
                    user: sdk.user,
                    session: sdk.session,
                    tab: sdk.context.getTab(),
                    tokenStore: {
                        getToken: sdk.getToken.bind(sdk),
                        setToken: sdk.setToken.bind(sdk),
                    },
                    cidAssigner: sdk.cidAssigner,
                    eventManager: sdk.eventManager,
                    getLogger: function () {
                        var namespace = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            namespace[_i] = arguments[_i];
                        }
                        return sdk.getLogger.apply(sdk, tslib_1.__spreadArray([PLUGIN_NAMESPACE, name_1], tslib_1.__read(namespace)));
                    },
                    getTabStorage: function () {
                        var namespace = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            namespace[_i] = arguments[_i];
                        }
                        return sdk.getTabStorage.apply(sdk, tslib_1.__spreadArray([PLUGIN_NAMESPACE, name_1], tslib_1.__read(namespace)));
                    },
                    getBrowserStorage: function () {
                        var namespace = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            namespace[_i] = arguments[_i];
                        }
                        return sdk.getBrowserStorage.apply(sdk, tslib_1.__spreadArray([PLUGIN_NAMESPACE, name_1], tslib_1.__read(namespace)));
                    },
                },
            };
            var plugin = void 0;
            try {
                plugin = factory(args);
            }
            catch (error) {
                logger.error("Failed to initialize plugin \"" + name_1 + "\": " + error_1.formatCause(error));
                return "continue";
            }
            logger.debug("Plugin \"" + name_1 + "\" initialized");
            if (typeof plugin !== 'object') {
                return "continue";
            }
            this_1.plugins[name_1] = plugin;
            var promise = plugin.enable();
            if (!(promise instanceof Promise)) {
                logger.debug("Plugin \"" + name_1 + "\" enabled");
                return "continue";
            }
            pending.push(promise
                .then(function () { return logger.debug("Plugin \"" + name_1 + "\" enabled"); })
                .catch(function (error) { return logger.error("Failed to enable plugin \"" + name_1 + "\": " + error_1.formatCause(error)); }));
        };
        var this_1 = this;
        try {
            for (var _f = tslib_1.__values(Object.entries(tslib_1.__assign({ playground: true }, plugins))), _g = _f.next(); !_g.done; _g = _f.next()) {
                var _h = tslib_1.__read(_g.value, 2), name_1 = _h[0], options = _h[1];
                _loop_1(name_1, options);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var initializeEap = (_e = window.croctEap) === null || _e === void 0 ? void 0 : _e.initialize;
        if (typeof initializeEap === 'function') {
            initializeEap.call(this);
        }
        Promise.all(pending).then(function () {
            _this.initialize();
            logger.debug('Initialization complete');
        });
    };
    Object.defineProperty(GlobalPlug.prototype, "initialized", {
        get: function () {
            return this.instance !== undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GlobalPlug.prototype, "plugged", {
        get: function () {
            var _this = this;
            return this.ready.then(function () { return _this; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GlobalPlug.prototype, "flushed", {
        get: function () {
            var _this = this;
            return this.tracker.flushed.then(function () { return _this; });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GlobalPlug.prototype, "sdk", {
        get: function () {
            if (this.instance === undefined) {
                throw new Error('Croct is not plugged in.');
            }
            return this.instance;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GlobalPlug.prototype, "tracker", {
        get: function () {
            return this.sdk.tracker;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GlobalPlug.prototype, "evaluator", {
        get: function () {
            return this.sdk.evaluator;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GlobalPlug.prototype, "user", {
        get: function () {
            return this.sdk.user;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(GlobalPlug.prototype, "session", {
        get: function () {
            return this.sdk.session;
        },
        enumerable: false,
        configurable: true
    });
    GlobalPlug.prototype.isAnonymous = function () {
        return this.sdk.context.isAnonymous();
    };
    GlobalPlug.prototype.getUserId = function () {
        return this.sdk.context.getUser();
    };
    GlobalPlug.prototype.identify = function (userId) {
        if (typeof userId !== 'string') {
            throw new Error('The user ID must be a string. Read more on https://croct.help/plug-js/id-conversion');
        }
        this.sdk.identify(userId);
    };
    GlobalPlug.prototype.anonymize = function () {
        this.sdk.anonymize();
    };
    GlobalPlug.prototype.setToken = function (token) {
        this.sdk.setToken(token_1.Token.parse(token));
    };
    GlobalPlug.prototype.unsetToken = function () {
        this.sdk.unsetToken();
    };
    GlobalPlug.prototype.track = function (type, payload) {
        return this.sdk.tracker.track(type, payload);
    };
    GlobalPlug.prototype.evaluate = function (expression, options) {
        if (options === void 0) { options = {}; }
        return this.sdk.evaluator.evaluate(expression, options);
    };
    GlobalPlug.prototype.test = function (expression, options) {
        if (options === void 0) { options = {}; }
        return this.evaluate(expression, options)
            .then(function (result) { return result === true; });
    };
    /**
     * This API is unstable and subject to change in future releases.
     */
    GlobalPlug.prototype.fetch = function (slotId, options) {
        if (options === void 0) { options = {}; }
        return this.eap('fetch').call(this, slotId, options);
    };
    GlobalPlug.prototype.unplug = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, instance, plugins, logger, pending, _loop_2, _b, _c, _d, pluginName, controller;
            var e_2, _e;
            var _this = this;
            return tslib_1.__generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        if (this.instance === undefined) {
                            return [2 /*return*/];
                        }
                        _a = this, instance = _a.instance, plugins = _a.plugins;
                        logger = this.sdk.getLogger();
                        pending = [];
                        _loop_2 = function (pluginName, controller) {
                            if (typeof controller.disable !== 'function') {
                                return "continue";
                            }
                            logger.debug("Disabling plugin \"" + pluginName + "\"...");
                            var promise = controller.disable();
                            if (!(promise instanceof Promise)) {
                                logger.debug("Plugin \"" + pluginName + "\" disabled");
                                return "continue";
                            }
                            pending.push(promise
                                .then(function () { return logger.debug("Plugin \"" + pluginName + "\" disabled"); })
                                .catch(function (error) { return logger.error("Failed to disable \"" + pluginName + "\": " + error_1.formatCause(error)); }));
                        };
                        try {
                            for (_b = tslib_1.__values(Object.entries(plugins)), _c = _b.next(); !_c.done; _c = _b.next()) {
                                _d = tslib_1.__read(_c.value, 2), pluginName = _d[0], controller = _d[1];
                                _loop_2(pluginName, controller);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_e = _b.return)) _e.call(_b);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        // Reset
                        delete this.instance;
                        this.plugins = {};
                        this.ready = new Promise(function (resolve) {
                            _this.initialize = resolve;
                        });
                        return [4 /*yield*/, Promise.all(pending)];
                    case 1:
                        _f.sent();
                        _f.label = 2;
                    case 2:
                        _f.trys.push([2, , 4, 5]);
                        return [4 /*yield*/, instance.close()];
                    case 3:
                        _f.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        logger.info('🔌 Croct has been unplugged.');
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    GlobalPlug.prototype.eap = function (feature) {
        var logger = this.sdk.getLogger();
        var eap = window.croctEap;
        var method = typeof eap === 'object' ? eap[feature] : undefined;
        if (typeof method !== 'function') {
            throw new Error("The " + feature + " feature is currently available only to accounts participating in our "
                + 'Early-Access Program (EAP). Please contact your Customer Success Manager or email eap@croct.com '
                + 'to check your account eligibility.');
        }
        logger.warn("The " + feature + " API is still unstable and subject to change in future releases.");
        return method;
    };
    return GlobalPlug;
}());
exports.GlobalPlug = GlobalPlug;
