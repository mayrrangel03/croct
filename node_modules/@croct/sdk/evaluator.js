"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Evaluator = exports.ExpressionError = exports.EvaluationError = exports.EvaluationErrorType = void 0;
var tslib_1 = require("tslib");
var constants_1 = require("./constants");
var error_1 = require("./error");
var sourceLocation_1 = require("./sourceLocation");
var EvaluationErrorType;
(function (EvaluationErrorType) {
    EvaluationErrorType["TIMEOUT"] = "https://croct.help/api/evaluation#timeout";
    EvaluationErrorType["UNEXPECTED_ERROR"] = "https://croct.help/api/evaluation#unexpected-error";
    EvaluationErrorType["INVALID_EXPRESSION"] = "https://croct.help/api/evaluation#invalid-expression";
    EvaluationErrorType["TOO_COMPLEX_EXPRESSION"] = "https://croct.help/api/evaluation#too-complex-expression";
    EvaluationErrorType["EVALUATION_FAILED"] = "https://croct.help/api/evaluation#evaluation-failed";
    EvaluationErrorType["UNALLOWED_RESULT"] = "https://croct.help/api/evaluation#unallowed-result";
    EvaluationErrorType["UNSERIALIZABLE_RESULT"] = "https://croct.help/api/evaluation#unserializable-result";
})(EvaluationErrorType = exports.EvaluationErrorType || (exports.EvaluationErrorType = {}));
var EvaluationError = /** @class */ (function (_super) {
    tslib_1.__extends(EvaluationError, _super);
    function EvaluationError(response) {
        var _this = _super.call(this, response.title) || this;
        _this.response = response;
        Object.setPrototypeOf(_this, EvaluationError.prototype);
        return _this;
    }
    return EvaluationError;
}(Error));
exports.EvaluationError = EvaluationError;
var ExpressionError = /** @class */ (function (_super) {
    tslib_1.__extends(ExpressionError, _super);
    function ExpressionError(response) {
        var _this = _super.call(this, response) || this;
        Object.setPrototypeOf(_this, ExpressionError.prototype);
        return _this;
    }
    return ExpressionError;
}(EvaluationError));
exports.ExpressionError = ExpressionError;
var Evaluator = /** @class */ (function () {
    function Evaluator(configuration) {
        var _a;
        this.configuration = tslib_1.__assign(tslib_1.__assign({}, configuration), { endpointUrl: (_a = configuration.endpointUrl) !== null && _a !== void 0 ? _a : constants_1.EVALUATION_ENDPOINT_URL });
    }
    Evaluator.prototype.evaluate = function (expression, options) {
        if (options === void 0) { options = {}; }
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var length, response, endpoint;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                length = (0, sourceLocation_1.getLength)(expression);
                if (length > Evaluator.MAX_EXPRESSION_LENGTH) {
                    response = {
                        title: 'The expression is too complex.',
                        status: 422,
                        type: EvaluationErrorType.TOO_COMPLEX_EXPRESSION,
                        detail: "The expression must be at most ".concat(Evaluator.MAX_EXPRESSION_LENGTH, " characters long, ")
                            + "but it is ".concat(length, " characters long."),
                        errors: [{
                                cause: 'The expression is longer than expected.',
                                location: (0, sourceLocation_1.getLocation)(expression, 0, Math.max(length - 1, 0)),
                            }],
                    };
                    return [2 /*return*/, Promise.reject(new ExpressionError(response))];
                }
                endpoint = new URL(this.configuration.endpointUrl);
                endpoint.searchParams.append('expression', expression);
                if (options.context !== undefined) {
                    endpoint.searchParams.append('context', JSON.stringify(options.context));
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        if (options.timeout !== undefined) {
                            window.setTimeout(function () {
                                var response = {
                                    title: 'Maximum evaluation timeout reached before evaluation could complete.',
                                    type: EvaluationErrorType.TIMEOUT,
                                    detail: "The evaluation took more than ".concat(options.timeout, "ms to complete."),
                                    status: 408, // Request Timeout
                                };
                                reject(new EvaluationError(response));
                            }, options.timeout);
                        }
                        var promise = _this.fetch(endpoint.toString());
                        promise.then(function (response) {
                            if (response.ok) {
                                response.json().then(resolve);
                                return;
                            }
                            response.json().then(function (result) {
                                var errorResponse = result;
                                switch (errorResponse.type) {
                                    case EvaluationErrorType.INVALID_EXPRESSION:
                                    case EvaluationErrorType.EVALUATION_FAILED:
                                    case EvaluationErrorType.TOO_COMPLEX_EXPRESSION:
                                        reject(new ExpressionError(errorResponse));
                                        break;
                                    default:
                                        reject(new EvaluationError(errorResponse));
                                        break;
                                }
                            });
                        }, function (error) {
                            var errorResponse = {
                                title: (0, error_1.formatMessage)(error),
                                type: EvaluationErrorType.UNEXPECTED_ERROR,
                                detail: 'Please try again or contact Croct support if the error persists.',
                                status: 500, // Internal Server Error
                            };
                            reject(new EvaluationError(errorResponse));
                        });
                    })];
            });
        });
    };
    Evaluator.prototype.fetch = function (endpoint) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a, tokenProvider, cidAssigner, appId, token, cid, headers;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.configuration, tokenProvider = _a.tokenProvider, cidAssigner = _a.cidAssigner, appId = _a.appId;
                        token = tokenProvider.getToken();
                        return [4 /*yield*/, cidAssigner.assignCid()];
                    case 1:
                        cid = _b.sent();
                        headers = tslib_1.__assign({ 'X-App-Id': appId, 'X-Client-Id': cid }, (token !== null && { 'X-Token': token.toString() }));
                        return [2 /*return*/, window.fetch(endpoint.toString(), {
                                method: 'GET',
                                headers: headers,
                                credentials: 'include',
                            })];
                }
            });
        });
    };
    Evaluator.MAX_EXPRESSION_LENGTH = constants_1.MAX_EXPRESSION_LENGTH;
    return Evaluator;
}());
exports.Evaluator = Evaluator;
