"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sdk = void 0;
var tslib_1 = require("tslib");
var container_1 = require("./container");
var constants_1 = require("./constants");
var schema_1 = require("./schema");
var error_1 = require("./error");
function validateConfiguration(configuration) {
    if (typeof configuration !== 'object' || configuration === null) {
        throw new Error('The configuration must be a key-value map.');
    }
    try {
        schema_1.sdkConfigurationSchema.validate(configuration);
    }
    catch (violation) {
        throw new Error("Invalid configuration: ".concat((0, error_1.formatCause)(violation)));
    }
}
var Sdk = /** @class */ (function () {
    function Sdk(container) {
        this.container = container;
    }
    Sdk.init = function (configuration) {
        var e_1, _a;
        var _b, _c, _d, _e;
        validateConfiguration(configuration);
        var _f = configuration.eventMetadata, customMetadata = _f === void 0 ? {} : _f, containerConfiguration = tslib_1.__rest(configuration, ["eventMetadata"]);
        var eventMetadata = {
            sdkVersion: constants_1.VERSION,
        };
        try {
            for (var _g = tslib_1.__values(Object.keys(customMetadata)), _h = _g.next(); !_h.done; _h = _g.next()) {
                var metadata = _h.value;
                eventMetadata["custom_".concat(metadata)] = customMetadata[metadata];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_a = _g.return)) _a.call(_g);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var container = new container_1.Container(tslib_1.__assign(tslib_1.__assign({}, containerConfiguration), { evaluationEndpointUrl: (_b = containerConfiguration.evaluationEndpointUrl) !== null && _b !== void 0 ? _b : constants_1.EVALUATION_ENDPOINT_URL, trackerEndpointUrl: (_c = containerConfiguration.trackerEndpointUrl) !== null && _c !== void 0 ? _c : constants_1.TRACKER_ENDPOINT_URL, bootstrapEndpointUrl: (_d = containerConfiguration.bootstrapEndpointUrl) !== null && _d !== void 0 ? _d : constants_1.BOOTSTRAP_ENDPOINT_URL, beaconQueueSize: (_e = containerConfiguration.beaconQueueSize) !== null && _e !== void 0 ? _e : 100, eventMetadata: eventMetadata }));
        var logger = container.getLogger();
        var _j = container.getConfiguration(), appId = _j.appId, tokenScope = _j.tokenScope;
        logger.debug('\n\n'
            + ' ██████ ██████   ██████   ██████ ████████ \n'
            + '██      ██   ██ ██    ██ ██         ██    \n'
            + '██      ██████  ██    ██ ██         ██    \n'
            + '██      ██   ██ ██    ██ ██         ██    \n'
            + ' ██████ ██   ██  ██████   ██████    ██    \n'
            + '\n');
        logger.info("Initializing SDK v".concat(constants_1.VERSION, "..."));
        logger.debug("App ID: ".concat(appId));
        var context = container.getContext();
        var tab = context.getTab();
        var user = context.getUser();
        logger.debug("".concat(tab.isNew ? 'New' : 'Current', " tab: ").concat(tab.id));
        logger.debug("Token scope: ".concat(tokenScope));
        logger.debug("Current user: ".concat(user !== null ? user : 'anonymous'));
        logger.debug("Test mode: ".concat(containerConfiguration.test));
        logger.info('⚡ Croct SDK is ready!');
        return new Sdk(container);
    };
    Object.defineProperty(Sdk.prototype, "appId", {
        get: function () {
            var appId = this.container.getConfiguration().appId;
            return appId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sdk.prototype, "cidAssigner", {
        get: function () {
            return this.container.getCidAssigner();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sdk.prototype, "context", {
        get: function () {
            return this.container.getContext();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sdk.prototype, "tracker", {
        get: function () {
            return this.container.getTracker();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sdk.prototype, "evaluator", {
        get: function () {
            return this.container.getEvaluator();
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Sdk.prototype, "eventManager", {
        get: function () {
            return this.container.getEventManager();
        },
        enumerable: false,
        configurable: true
    });
    Sdk.prototype.getLogger = function () {
        var _a;
        var namespace = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            namespace[_i] = arguments[_i];
        }
        return (_a = this.container).getLogger.apply(_a, tslib_1.__spreadArray([], tslib_1.__read(namespace), false));
    };
    Sdk.prototype.getTabStorage = function (namespace) {
        var _a;
        var subnamespace = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            subnamespace[_i - 1] = arguments[_i];
        }
        return (_a = this.container).getTabStorage.apply(_a, tslib_1.__spreadArray([namespace], tslib_1.__read(subnamespace), false));
    };
    Sdk.prototype.getBrowserStorage = function (namespace) {
        var _a;
        var subnamespace = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            subnamespace[_i - 1] = arguments[_i];
        }
        return (_a = this.container).getBrowserStorage.apply(_a, tslib_1.__spreadArray([namespace], tslib_1.__read(subnamespace), false));
    };
    Sdk.prototype.close = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var logger;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.closed) {
                            return [2 /*return*/];
                        }
                        logger = this.getLogger();
                        logger.debug('Closing SDK...');
                        this.closed = true;
                        return [4 /*yield*/, this.container.dispose()];
                    case 1:
                        _a.sent();
                        logger.info('SDK closed.');
                        return [2 /*return*/];
                }
            });
        });
    };
    return Sdk;
}());
exports.Sdk = Sdk;
