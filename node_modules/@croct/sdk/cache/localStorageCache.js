"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorageCache = void 0;
var LocalStorageCache = /** @class */ (function () {
    function LocalStorageCache(storage, key) {
        this.listeners = [];
        this.storage = storage;
        this.key = key;
        this.value = storage.getItem(key);
    }
    LocalStorageCache.autoSync = function (cache) {
        var listener = cache.sync.bind(cache);
        window.addEventListener('storage', listener);
        return function () { return window.removeEventListener('storage', listener); };
    };
    LocalStorageCache.prototype.get = function () {
        return this.value;
    };
    LocalStorageCache.prototype.put = function (value) {
        this.storage.setItem(this.key, value);
        if (this.value !== value) {
            this.value = value;
            this.notifyChange(value);
        }
    };
    LocalStorageCache.prototype.clear = function () {
        this.storage.removeItem(this.key);
        if (this.value !== null) {
            this.value = null;
            this.notifyChange(null);
        }
    };
    LocalStorageCache.prototype.addListener = function (listener) {
        if (!this.listeners.includes(listener)) {
            this.listeners.push(listener);
        }
    };
    LocalStorageCache.prototype.removeListener = function (listener) {
        var index = this.listeners.indexOf(listener);
        if (index > -1) {
            this.listeners.splice(index, 1);
        }
    };
    LocalStorageCache.prototype.notifyChange = function (value) {
        this.listeners.forEach(function (listener) { return listener(value); });
    };
    LocalStorageCache.prototype.sync = function (event) {
        if (event.storageArea !== this.storage || (event.key !== null && event.key !== this.key)) {
            // Ignore unrelated changes
            return;
        }
        /*
         * Retrieving the value from the store rather than the event ensures
         * the cache will be in sync with the latest value set.
         * In case of cascading changes, it prevents notifying listeners
         * about intermediate states already outdated at this point.
         */
        var value = this.storage.getItem(this.key);
        if (this.value !== value) {
            this.value = value;
            this.notifyChange(value);
        }
    };
    return LocalStorageCache;
}());
exports.LocalStorageCache = LocalStorageCache;
