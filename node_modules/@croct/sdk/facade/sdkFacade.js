"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkFacade = void 0;
var tslib_1 = require("tslib");
var evaluatorFacade_1 = require("./evaluatorFacade");
var trackerFacade_1 = require("./trackerFacade");
var userFacade_1 = require("./userFacade");
var token_1 = require("../token");
var error_1 = require("../error");
var schema_1 = require("../schema");
var sdk_1 = require("../sdk");
var sessionFacade_1 = require("./sessionFacade");
function validateConfiguration(configuration) {
    if (typeof configuration !== 'object' || configuration === null) {
        throw new Error('The configuration must be a key-value map.');
    }
    try {
        schema_1.sdkFacadeConfigurationSchema.validate(configuration);
    }
    catch (violation) {
        throw new Error("Invalid configuration: ".concat((0, error_1.formatCause)(violation)));
    }
}
var SdkFacade = /** @class */ (function () {
    function SdkFacade(sdk) {
        this.sdk = sdk;
    }
    SdkFacade.init = function (configuration) {
        var _a, _b, _c;
        validateConfiguration(configuration);
        var _d = configuration.track, track = _d === void 0 ? true : _d, userId = configuration.userId, token = configuration.token, containerConfiguration = tslib_1.__rest(configuration, ["track", "userId", "token"]);
        if (userId !== undefined && token !== undefined) {
            throw new Error('Either the user ID or token can be specified, but not both.');
        }
        var sdk = new SdkFacade(sdk_1.Sdk.init(tslib_1.__assign(tslib_1.__assign({}, containerConfiguration), { tokenScope: (_a = containerConfiguration.tokenScope) !== null && _a !== void 0 ? _a : 'global', debug: (_b = containerConfiguration.debug) !== null && _b !== void 0 ? _b : false, test: (_c = containerConfiguration.test) !== null && _c !== void 0 ? _c : false })));
        if (userId !== undefined) {
            sdk.identify(userId);
        }
        else if (token !== undefined) {
            if (token === null) {
                sdk.unsetToken();
            }
            else {
                sdk.setToken(token_1.Token.parse(token));
            }
        }
        if (track) {
            sdk.tracker.enable();
        }
        return sdk;
    };
    Object.defineProperty(SdkFacade.prototype, "context", {
        get: function () {
            return this.sdk.context;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SdkFacade.prototype, "cidAssigner", {
        get: function () {
            return this.sdk.cidAssigner;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SdkFacade.prototype, "tracker", {
        get: function () {
            if (this.trackerFacade === undefined) {
                this.trackerFacade = new trackerFacade_1.TrackerFacade(this.sdk.tracker);
            }
            return this.trackerFacade;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SdkFacade.prototype, "user", {
        get: function () {
            if (this.userFacade === undefined) {
                this.userFacade = new userFacade_1.UserFacade(this.context, this.sdk.tracker);
            }
            return this.userFacade;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SdkFacade.prototype, "session", {
        get: function () {
            if (this.sessionFacade === undefined) {
                this.sessionFacade = new sessionFacade_1.SessionFacade(this.sdk.tracker);
            }
            return this.sessionFacade;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SdkFacade.prototype, "evaluator", {
        get: function () {
            if (this.evaluatorFacade === undefined) {
                this.evaluatorFacade = new evaluatorFacade_1.EvaluatorFacade(this.sdk.evaluator, new evaluatorFacade_1.TabContextFactory(this.sdk.context.getTab()));
            }
            return this.evaluatorFacade;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SdkFacade.prototype, "eventManager", {
        get: function () {
            var eventManager = this.sdk.eventManager;
            return {
                addListener: eventManager.addListener.bind(eventManager),
                removeListener: eventManager.removeListener.bind(eventManager),
                dispatch: function (eventName, event) {
                    if (!/[a-z][a-z_]+\.[a-z][a-z_]+/i.test(eventName)) {
                        throw new Error('The event name must be in the form of "namespaced.eventName", where '
                            + 'both the namespace and event name must start with a letter, followed by '
                            + 'any series of letters and underscores.');
                    }
                    eventManager.dispatch(eventName, event);
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    SdkFacade.prototype.identify = function (userId) {
        this.setToken(token_1.Token.issue(this.sdk.appId, userId));
    };
    SdkFacade.prototype.anonymize = function () {
        if (!this.context.isAnonymous()) {
            this.unsetToken();
        }
    };
    SdkFacade.prototype.getToken = function () {
        return this.context.getToken();
    };
    SdkFacade.prototype.setToken = function (token) {
        var _a;
        var currentToken = this.getToken();
        if (currentToken !== null && currentToken.toString() === token.toString()) {
            return;
        }
        var currentSubject = (_a = currentToken === null || currentToken === void 0 ? void 0 : currentToken.getSubject()) !== null && _a !== void 0 ? _a : null;
        var subject = token.getSubject();
        var logger = this.getLogger();
        if (subject === currentSubject) {
            this.context.setToken(token);
            logger.debug('Token refreshed');
            return;
        }
        if (currentSubject !== null) {
            this.trackInternalEvent({
                type: 'userSignedOut',
                userId: currentSubject,
            });
            logger.info('User signed out');
        }
        this.context.setToken(token);
        if (subject !== null) {
            this.trackInternalEvent({
                type: 'userSignedIn',
                userId: subject,
            });
            logger.info("User signed in as ".concat(subject));
        }
        logger.debug('New token saved, ');
    };
    SdkFacade.prototype.unsetToken = function () {
        var token = this.getToken();
        if (token === null) {
            return;
        }
        var logger = this.getLogger();
        var subject = token.getSubject();
        if (subject !== null) {
            this.trackInternalEvent({
                type: 'userSignedOut',
                userId: subject,
            });
            logger.info('User signed out');
        }
        this.context.setToken(null);
        logger.debug('Token removed');
    };
    SdkFacade.prototype.trackInternalEvent = function (event) {
        this.sdk.tracker.track(event).catch(function () {
            // suppress error as it is already logged by the tracker
        });
    };
    SdkFacade.prototype.getLogger = function () {
        var _a;
        var namespace = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            namespace[_i] = arguments[_i];
        }
        return (_a = this.sdk).getLogger.apply(_a, tslib_1.__spreadArray([], tslib_1.__read(namespace), false));
    };
    SdkFacade.prototype.getTabStorage = function (namespace) {
        var _a;
        var subnamespace = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            subnamespace[_i - 1] = arguments[_i];
        }
        return (_a = this.sdk).getTabStorage.apply(_a, tslib_1.__spreadArray([namespace], tslib_1.__read(subnamespace), false));
    };
    SdkFacade.prototype.getBrowserStorage = function (namespace) {
        var _a;
        var subnamespace = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            subnamespace[_i - 1] = arguments[_i];
        }
        return (_a = this.sdk).getBrowserStorage.apply(_a, tslib_1.__spreadArray([namespace], tslib_1.__read(subnamespace), false));
    };
    SdkFacade.prototype.close = function () {
        return this.sdk.close();
    };
    return SdkFacade;
}());
exports.SdkFacade = SdkFacade;
