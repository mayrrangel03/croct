"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketChannel = void 0;
var tslib_1 = require("tslib");
var logging_1 = require("../logging");
var error_1 = require("../error");
var SocketChannel = /** @class */ (function () {
    function SocketChannel(_a) {
        var _b, _c, _d;
        var url = _a.url, logger = _a.logger, options = tslib_1.__rest(_a, ["url", "logger"]);
        this.listeners = [];
        this.closed = false;
        this.url = url;
        this.logger = logger !== null && logger !== void 0 ? logger : new logging_1.NullLogger();
        this.options = tslib_1.__assign(tslib_1.__assign({}, options), { closeTimeout: (_b = options.closeTimeout) !== null && _b !== void 0 ? _b : 5000, connectionTimeout: (_c = options.connectionTimeout) !== null && _c !== void 0 ? _c : 10000, protocols: (_d = options.protocols) !== null && _d !== void 0 ? _d : [] });
    }
    Object.defineProperty(SocketChannel.prototype, "connected", {
        get: function () {
            if (this.connection === undefined) {
                return Promise.resolve(false);
            }
            return this.connection.then(function () { return true; }, function () { return false; });
        },
        enumerable: false,
        configurable: true
    });
    SocketChannel.prototype.publish = function (message) {
        var _this = this;
        return this.connect().then(function (socket) {
            socket.send(message);
            _this.logger.debug('Message sent.');
        });
    };
    SocketChannel.prototype.subscribe = function (listener) {
        if (!this.listeners.includes(listener)) {
            this.listeners.push(listener);
        }
    };
    SocketChannel.prototype.unsubscribe = function (listener) {
        var index = this.listeners.indexOf(listener);
        if (index >= 0) {
            this.listeners.splice(index, 1);
        }
    };
    SocketChannel.prototype.notify = function (message) {
        this.listeners.forEach(function (dispatch) { return dispatch(message); });
    };
    SocketChannel.prototype.connect = function () {
        var _this = this;
        if (this.closed) {
            return Promise.reject(new Error('Channel has been closed.'));
        }
        if (this.connection !== undefined) {
            return this.connection.then(function (connection) {
                var state = connection.readyState;
                if (state === WebSocket.OPEN) {
                    return connection;
                }
                throw new Error('Connection lost.');
            }).catch(function () {
                // Reconnect
                delete _this.connection;
                return _this.connect();
            });
        }
        this.connection = new Promise(function (resolve, reject) {
            _this.logger.debug('Connecting...');
            var connection = new window.WebSocket(_this.url, _this.options.protocols);
            if (_this.options.binaryType) {
                connection.binaryType = _this.options.binaryType;
            }
            var abortListener = function () {
                var reason = 'Maximum connection timeout reached.';
                _this.logger.error(reason);
                reject(new Error(reason));
                connection.close(1000, reason);
            };
            var abortTimer = window.setTimeout(abortListener, _this.options.connectionTimeout);
            var openListener = function () {
                window.clearTimeout(abortTimer);
                _this.logger.info('Connection established.');
                connection.removeEventListener('open', openListener);
                resolve(connection);
            };
            var errorListener = function () {
                if (!_this.closed) {
                    _this.logger.error('Connection error.');
                }
            };
            var messageListener = function (event) {
                _this.logger.debug('Message received.');
                _this.notify(event.data);
            };
            var closeListener = function (event) {
                window.clearTimeout(abortTimer);
                var reason = "".concat((0, error_1.formatCause)(event.reason || 'unknown'), " (code ").concat(event.code, ")");
                var message = "Connection has been closed, reason: ".concat(reason);
                if (!_this.closed) {
                    _this.logger.info(message);
                }
                connection.removeEventListener('open', openListener);
                connection.removeEventListener('error', errorListener);
                connection.removeEventListener('close', closeListener);
                connection.removeEventListener('message', messageListener);
                reject(new Error(message));
            };
            connection.addEventListener('open', openListener, { once: true });
            connection.addEventListener('close', closeListener, { once: true });
            connection.addEventListener('error', errorListener);
            connection.addEventListener('message', messageListener);
        });
        return this.connection;
    };
    SocketChannel.prototype.close = function () {
        var _this = this;
        this.logger.debug('Closing connection...');
        return new Promise(function (resolve, reject) {
            _this.closed = true;
            if (_this.connection === undefined) {
                _this.logger.debug('Connection is not open.');
                resolve();
                return;
            }
            _this.connection.then(function (connection) {
                var abortTimer;
                var abort = function () {
                    _this.logger.warn('Connection could not be closed within the timeout period.');
                    reject(new Error('Maximum close timeout reached.'));
                };
                var close = function () {
                    window.clearTimeout(abortTimer);
                    _this.logger.info('Connection gracefully closed.');
                    resolve();
                };
                connection.addEventListener('close', close, { once: true });
                connection.close(1000, 'Deliberate disconnection.');
                abortTimer = window.setTimeout(abort, _this.options.closeTimeout);
            }, function () {
                _this.logger.info('Connection closed.');
                resolve();
            });
        });
    };
    return SocketChannel;
}());
exports.SocketChannel = SocketChannel;
