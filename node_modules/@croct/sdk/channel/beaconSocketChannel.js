"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeaconSocketChannel = void 0;
var tslib_1 = require("tslib");
var logging_1 = require("../logging");
var BeaconSocketChannel = /** @class */ (function () {
    function BeaconSocketChannel(configuration) {
        var _a, _b;
        this.listeners = [];
        this.connectionIndex = 0;
        this.socketFactory = configuration.channelFactory;
        this.logger = (_a = configuration.logger) !== null && _a !== void 0 ? _a : new logging_1.NullLogger();
        this.loggerFactory = (_b = configuration.loggerFactory) !== null && _b !== void 0 ? _b : (function () { return new logging_1.NullLogger(); });
        this.cidAssigner = configuration.cidAssigner;
        this.cidParameter = configuration.cidParameter;
        this.trackerEndpointUrl = configuration.trackerEndpointUrl;
        this.tokenParameter = configuration.tokenParameter;
        this.notify = this.notify.bind(this);
    }
    BeaconSocketChannel.prototype.publish = function (_a) {
        var receiptId = _a.id, message = _a.message;
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _b, token, timestamp, context, payload, _c;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = JSON.parse(message), token = _b.token, timestamp = _b.timestamp, context = _b.context, payload = _b.payload;
                        if (!(this.token !== token || this.socketChannel === undefined)) return [3 /*break*/, 4];
                        if (!(this.socketChannel !== undefined)) return [3 /*break*/, 2];
                        this.logger.info('Connection no longer valid for current message.');
                        this.socketChannel.unsubscribe(this.notify);
                        return [4 /*yield*/, this.socketChannel.close()];
                    case 1:
                        _d.sent();
                        _d.label = 2;
                    case 2:
                        this.token = token;
                        _c = this;
                        return [4 /*yield*/, this.createSocketChannel(token)];
                    case 3:
                        _c.socketChannel = _d.sent();
                        _d.label = 4;
                    case 4: return [2 /*return*/, this.socketChannel.publish(JSON.stringify({
                            receiptId: receiptId,
                            originalTime: timestamp,
                            departureTime: Date.now(),
                            context: context,
                            payload: payload,
                        }))];
                }
            });
        });
    };
    BeaconSocketChannel.prototype.createSocketChannel = function (token) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var endpoint, _a, _b, _c, channel;
            return tslib_1.__generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        endpoint = new URL(this.trackerEndpointUrl);
                        _b = (_a = endpoint.searchParams).append;
                        _c = [this.cidParameter];
                        return [4 /*yield*/, this.cidAssigner.assignCid()];
                    case 1:
                        _b.apply(_a, _c.concat([_d.sent()]));
                        if (token !== undefined) {
                            endpoint.searchParams.append(this.tokenParameter, token);
                        }
                        channel = this.socketFactory(endpoint.toString(), this.loggerFactory("WebSocket#".concat(this.connectionIndex)));
                        this.connectionIndex += 1;
                        channel.subscribe(this.notify);
                        return [2 /*return*/, channel];
                }
            });
        });
    };
    BeaconSocketChannel.prototype.subscribe = function (listener) {
        if (!this.listeners.includes(listener)) {
            this.listeners.push(listener);
        }
    };
    BeaconSocketChannel.prototype.unsubscribe = function (listener) {
        var index = this.listeners.indexOf(listener);
        if (index >= 0) {
            this.listeners.splice(index, 1);
        }
    };
    BeaconSocketChannel.prototype.notify = function (message) {
        var _this = this;
        var confirmation;
        try {
            confirmation = JSON.parse(message);
        }
        catch (_a) {
            this.logger.error('Invalid JSON message received.');
            return;
        }
        var _b = confirmation.violations, violations = _b === void 0 ? [] : _b, receiptId = confirmation.receiptId;
        violations.forEach(function (violation) { return _this.logger.error(violation.message); });
        if (receiptId !== null) {
            this.listeners.forEach(function (dispatch) { return dispatch(receiptId); });
        }
    };
    BeaconSocketChannel.prototype.close = function () {
        if (this.socketChannel === undefined) {
            return Promise.resolve();
        }
        return this.socketChannel.close();
    };
    return BeaconSocketChannel;
}());
exports.BeaconSocketChannel = BeaconSocketChannel;
