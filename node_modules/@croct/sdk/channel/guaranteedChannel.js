"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuaranteedChannel = exports.TimeStamper = void 0;
var tslib_1 = require("tslib");
var logging_1 = require("../logging");
var TimeStamper = /** @class */ (function () {
    function TimeStamper() {
    }
    TimeStamper.prototype.generate = function () {
        return String(Date.now());
    };
    return TimeStamper;
}());
exports.TimeStamper = TimeStamper;
var GuaranteedChannel = /** @class */ (function () {
    function GuaranteedChannel(_a) {
        var _b;
        var channel = _a.channel, logger = _a.logger, stamper = _a.stamper, options = tslib_1.__rest(_a, ["channel", "logger", "stamper"]);
        this.closed = false;
        this.channel = channel;
        this.logger = logger !== null && logger !== void 0 ? logger : new logging_1.NullLogger();
        this.stamper = stamper;
        this.options = tslib_1.__assign(tslib_1.__assign({}, options), { ackTimeout: (_b = options.ackTimeout) !== null && _b !== void 0 ? _b : 5000 });
    }
    GuaranteedChannel.prototype.publish = function (message) {
        var _this = this;
        if (this.closed) {
            return Promise.reject(new Error('Channel is closed.'));
        }
        return new Promise(function (resolve, reject) {
            var id = _this.stamper.generate(message);
            var timeoutTimer;
            var closeWatcher;
            var confirmed = false;
            var start = Date.now();
            var acknowledge = function (response) {
                if (response === id) {
                    confirmed = true;
                    var elapsed = Date.now() - start;
                    window.clearTimeout(timeoutTimer);
                    window.clearInterval(closeWatcher);
                    _this.logger.debug("Delivery confirmed #".concat(id, ", elapsed ").concat(elapsed, "ms."));
                    _this.channel.unsubscribe(acknowledge);
                    resolve();
                }
            };
            _this.channel.subscribe(acknowledge);
            var abort = function (error) {
                window.clearTimeout(timeoutTimer);
                window.clearInterval(closeWatcher);
                _this.logger.error("Failed to send message #".concat(id));
                _this.channel.unsubscribe(acknowledge);
                reject(error);
            };
            var wait = function () {
                if (confirmed) {
                    return;
                }
                closeWatcher = window.setInterval(function () {
                    if (_this.closed) {
                        // Cancel delay immediately when the channel is closed
                        abort(new Error('Connection deliberately closed.'));
                    }
                }, 0);
                _this.logger.debug("Waiting confirmation #".concat(id, "..."));
                timeoutTimer = window.setTimeout(function () {
                    abort(new Error('Maximum confirmation time reached.'));
                }, _this.options.ackTimeout);
            };
            _this.logger.debug("Sending message #".concat(id, "..."));
            _this.channel.publish({ id: id, message: message }).then(wait, abort);
        });
    };
    GuaranteedChannel.prototype.close = function () {
        this.closed = true;
        return this.channel.close();
    };
    return GuaranteedChannel;
}());
exports.GuaranteedChannel = GuaranteedChannel;
