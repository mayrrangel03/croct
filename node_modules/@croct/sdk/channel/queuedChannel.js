"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueuedChannel = void 0;
var tslib_1 = require("tslib");
var logging_1 = require("../logging");
var QueuedChannel = /** @class */ (function () {
    function QueuedChannel(channel, queue, logger) {
        this.closed = false;
        this.channel = channel;
        this.queue = queue;
        this.logger = logger !== null && logger !== void 0 ? logger : new logging_1.NullLogger();
    }
    QueuedChannel.prototype.flush = function () {
        if (this.pending === undefined) {
            return this.requeue();
        }
        return this.pending.catch(this.requeue.bind(this));
    };
    QueuedChannel.prototype.publish = function (message) {
        var _this = this;
        if (this.closed) {
            return Promise.reject(new Error('Channel is closed.'));
        }
        if (this.queue.length() >= this.queue.getCapacity()) {
            this.logger.warn('The queue is full, message rejected.');
            return Promise.reject(new Error('The queue is full.'));
        }
        if (this.pending === undefined) {
            this.pending = this.queue.isEmpty()
                ? Promise.resolve()
                : Promise.reject(new Error('The queue must be flushed.'));
        }
        this.enqueue(message);
        this.pending = this.pending.then(function () { return _this.channel.publish(message).then(_this.dequeue.bind(_this)); });
        return this.pending;
    };
    QueuedChannel.prototype.enqueue = function (message) {
        this.logger.debug('Enqueueing message...');
        this.logger.debug("Queue length: ".concat(this.queue.length() + 1));
        this.queue.push(message);
    };
    QueuedChannel.prototype.dequeue = function () {
        this.logger.debug('Dequeuing message...');
        this.logger.debug("Queue length: ".concat(Math.max(0, this.queue.length() - 1)));
        this.queue.shift();
    };
    QueuedChannel.prototype.requeue = function () {
        var e_1, _a;
        var _this = this;
        if (this.closed) {
            return Promise.reject(new Error('Channel is closed.'));
        }
        this.pending = Promise.resolve();
        if (this.queue.isEmpty()) {
            return this.pending;
        }
        var length = this.queue.length();
        this.logger.debug('Requeuing messages...');
        this.logger.debug("Queue length: ".concat(length));
        var _loop_1 = function (message) {
            this_1.pending = this_1.pending.then(function () { return _this.channel.publish(message).then(_this.dequeue.bind(_this)); });
        };
        var this_1 = this;
        try {
            for (var _b = tslib_1.__values(this.queue.all()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var message = _c.value;
                _loop_1(message);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this.pending;
    };
    QueuedChannel.prototype.close = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _a;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.closed = true;
                        return [4 /*yield*/, this.channel.close()];
                    case 1:
                        _b.sent();
                        if (!(this.pending !== undefined)) return [3 /*break*/, 5];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.pending];
                    case 3:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        _a = _b.sent();
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return QueuedChannel;
}());
exports.QueuedChannel = QueuedChannel;
