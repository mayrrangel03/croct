"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixedTokenProvider = exports.Token = void 0;
var tslib_1 = require("tslib");
var base64Url_1 = require("../base64Url");
var schema_1 = require("../schema");
var error_1 = require("../error");
var Token = /** @class */ (function () {
    function Token(headers, claims, signature) {
        if (signature === void 0) { signature = ''; }
        this.headers = headers;
        this.claims = claims;
        this.signature = signature;
    }
    Token.issue = function (appId, subject, timestamp) {
        if (subject === void 0) { subject = null; }
        if (timestamp === void 0) { timestamp = Math.floor(Date.now() / 1000); }
        if (timestamp < 0) {
            throw new Error('The timestamp must be non-negative.');
        }
        if (subject === '') {
            throw new Error('The subject must be non-empty.');
        }
        return new Token({
            typ: 'JWT',
            alg: 'none',
            appId: appId,
        }, tslib_1.__assign({ iss: 'croct.io', aud: 'croct.io', iat: timestamp }, (subject !== null ? { sub: subject } : null)));
    };
    Token.parse = function (token) {
        if (token === '') {
            throw new Error('The token cannot be empty.');
        }
        var parts = token.split('.', 3);
        // This token is invalid
        if (parts.length < 2) {
            throw new Error('The token is malformed.');
        }
        var headers;
        var claims;
        var signature;
        try {
            headers = JSON.parse((0, base64Url_1.base64UrlDecode)(parts[0]));
            claims = JSON.parse((0, base64Url_1.base64UrlDecode)(parts[1]));
            if (parts.length === 3) {
                signature = (0, base64Url_1.base64UrlDecode)(parts[2]);
            }
        }
        catch (_a) {
            throw new Error('The token is corrupted.');
        }
        try {
            schema_1.tokenSchema.validate({ headers: headers, claims: claims, signature: signature });
        }
        catch (violation) {
            throw new Error("The token is invalid: ".concat((0, error_1.formatCause)(violation)));
        }
        return new Token(headers, claims, signature);
    };
    Token.prototype.getHeaders = function () {
        return tslib_1.__assign({}, this.headers);
    };
    Token.prototype.getClaims = function () {
        return tslib_1.__assign({}, this.claims);
    };
    Token.prototype.getSignature = function () {
        return this.signature;
    };
    Token.prototype.isAnonymous = function () {
        return this.claims.sub === undefined;
    };
    Token.prototype.getSubject = function () {
        return this.claims.sub !== undefined ? this.claims.sub : null;
    };
    Token.prototype.getIssueTime = function () {
        return this.claims.iat;
    };
    Token.prototype.toJSON = function () {
        return this.toString();
    };
    Token.prototype.toString = function () {
        var headers = (0, base64Url_1.base64UrlEncode)(JSON.stringify(this.headers));
        var claims = (0, base64Url_1.base64UrlEncode)(JSON.stringify(this.claims));
        var signature = (0, base64Url_1.base64UrlEncode)(this.signature);
        return "".concat(headers, ".").concat(claims, ".").concat(signature);
    };
    return Token;
}());
exports.Token = Token;
var FixedTokenProvider = /** @class */ (function () {
    function FixedTokenProvider(token) {
        this.token = token;
    }
    FixedTokenProvider.prototype.getToken = function () {
        return this.token;
    };
    return FixedTokenProvider;
}());
exports.FixedTokenProvider = FixedTokenProvider;
