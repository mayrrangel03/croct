"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackoffPolicy = void 0;
var BackoffPolicy = /** @class */ (function () {
    function BackoffPolicy(options) {
        if (options === void 0) { options = {}; }
        this.minRetryDelay = 1000;
        this.maxRetryDelay = 30000;
        this.backoffFactor = 2;
        this.backoffJitter = 1;
        this.maxAttempts = Infinity;
        var _a = options.minRetryDelay, minRetryDelay = _a === void 0 ? this.minRetryDelay : _a, _b = options.maxRetryDelay, maxRetryDelay = _b === void 0 ? this.maxRetryDelay : _b, _c = options.backoffFactor, backoffFactor = _c === void 0 ? this.backoffFactor : _c, _d = options.backoffJitter, backoffJitter = _d === void 0 ? this.backoffJitter : _d, _e = options.maxAttempts, maxAttempts = _e === void 0 ? this.maxAttempts : _e;
        if (minRetryDelay < 0) {
            throw new Error('The minimum retry delay must be non-negative.');
        }
        if (maxRetryDelay < minRetryDelay) {
            throw new Error('The maximum retry delay must be greater than the minimum.');
        }
        if (backoffFactor < 1) {
            throw new Error('The backoff factor must be greater than zero.');
        }
        if (backoffJitter < 0) {
            throw new Error('The backoff jitter must be non-negative.');
        }
        if (maxAttempts < 0) {
            throw new Error('The maximum attempts must be non-negative.');
        }
        this.minRetryDelay = minRetryDelay;
        this.maxRetryDelay = maxRetryDelay;
        this.backoffFactor = backoffFactor;
        this.backoffJitter = backoffJitter;
        this.maxAttempts = maxAttempts;
    }
    /**
     * Full Jitter algorithm
     *
     * @see https://www.awsarchitectureblog.com/2015/03/backoff.html
     */
    BackoffPolicy.prototype.getDelay = function (attempt) {
        var delay = Math.min(Math.max(Math.pow(this.backoffFactor, attempt), this.minRetryDelay), this.maxRetryDelay);
        if (this.backoffJitter > 0) {
            // Jitter will result in a random value between the minimum and
            // calculated delay for a given attempt.
            var min = Math.ceil(this.minRetryDelay);
            var max = Math.floor(delay);
            delay = Math.floor(Math.random() * (max - min + 1)) + min;
        }
        // Removing any fractional digits
        delay -= delay % 1;
        return delay;
    };
    BackoffPolicy.prototype.shouldRetry = function (attempt) {
        return attempt < this.maxAttempts;
    };
    return BackoffPolicy;
}());
exports.BackoffPolicy = BackoffPolicy;
