"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectType = void 0;
var tslib_1 = require("tslib");
var schema_1 = require("./schema");
var mixedSchema_1 = require("./mixedSchema");
var violation_1 = require("./violation");
var ObjectType = /** @class */ (function () {
    function ObjectType(schema) {
        if (schema === void 0) { schema = {}; }
        var _a, _b, _c, _d, _e, _f;
        this.definition = tslib_1.__assign(tslib_1.__assign({}, schema), { properties: (_a = schema.properties) !== null && _a !== void 0 ? _a : {}, required: (_b = schema.required) !== null && _b !== void 0 ? _b : [], additionalProperties: (_c = schema.additionalProperties) !== null && _c !== void 0 ? _c : false, propertyNames: (_d = schema.propertyNames) !== null && _d !== void 0 ? _d : new mixedSchema_1.MixedSchema(), minProperties: (_e = schema.minProperties) !== null && _e !== void 0 ? _e : -1, maxProperties: (_f = schema.maxProperties) !== null && _f !== void 0 ? _f : -1 });
    }
    ObjectType.prototype.getTypes = function () {
        if (this.definition.type !== undefined) {
            return [this.definition.type.name];
        }
        return ['object'];
    };
    // eslint-disable-next-line @typescript-eslint/ban-types
    ObjectType.prototype.isValidType = function (value) {
        if (this.definition.type !== undefined) {
            return value instanceof this.definition.type;
        }
        return Object.prototype.toString.call(value) === '[object Object]';
    };
    ObjectType.prototype.validate = function (value, path) {
        var e_1, _a, e_2, _b;
        if (path === void 0) { path = []; }
        if (!this.isValidType(value)) {
            var _c = tslib_1.__read(this.getTypes(), 1), type = _c[0];
            throw new schema_1.Violation("Expected value of type ".concat(type, " at path '").concat((0, violation_1.formatPath)(path), "', ")
                + "actual ".concat((0, violation_1.describe)(value), "."), path, { type: type });
        }
        var entries = Object.entries(value);
        var _d = this.definition, minProperties = _d.minProperties, maxProperties = _d.maxProperties;
        if (minProperties >= 0 && minProperties > entries.length) {
            throw new schema_1.Violation("Expected ".concat(minProperties === maxProperties ? 'exactly' : 'at least', " ")
                + "".concat(minProperties, " ").concat(minProperties === 1 ? 'entry' : 'entries', " ")
                + "at path '".concat((0, violation_1.formatPath)(path), "', actual ").concat(entries.length, "."), path, { limit: minProperties });
        }
        if (maxProperties >= 0 && maxProperties < entries.length) {
            throw new schema_1.Violation("Expected ".concat(minProperties === maxProperties ? 'exactly' : 'at most', " ")
                + "".concat(maxProperties, " ").concat(maxProperties === 1 ? 'entry' : 'entries', " ")
                + "at path '".concat((0, violation_1.formatPath)(path), "', actual ").concat(entries.length, "."), path, { limit: maxProperties });
        }
        var additionalProperties = tslib_1.__assign({}, value);
        try {
            for (var _e = tslib_1.__values(this.definition.required), _f = _e.next(); !_f.done; _f = _e.next()) {
                var property = _f.value;
                if (!(property in value)) {
                    throw new schema_1.Violation("Missing property '".concat((0, violation_1.formatPath)(path.concat([property])), "'."), path, {
                        required: property,
                    });
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var entries_1 = tslib_1.__values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                var _g = tslib_1.__read(entries_1_1.value, 2), entryName = _g[0], entryValue = _g[1];
                var propertyPath = path.concat([entryName]);
                this.definition.propertyNames.validate(entryName, propertyPath);
                var propertyRule = this.definition.properties[entryName];
                if (propertyRule !== undefined) {
                    propertyRule.validate(entryValue, propertyPath);
                    delete additionalProperties[entryName];
                    continue;
                }
                if (this.definition.additionalProperties === false) {
                    throw new schema_1.Violation("Unknown property '".concat((0, violation_1.formatPath)(propertyPath), "'."), propertyPath, {
                        additionalProperty: entryName,
                    });
                }
                if (this.definition.additionalProperties !== true) {
                    this.definition.additionalProperties.validate(entryValue, propertyPath);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (entries_1_1 && !entries_1_1.done && (_b = entries_1.return)) _b.call(entries_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var subtypes = this.definition.subtypes;
        if (subtypes !== undefined) {
            var type = value[subtypes.discriminator];
            if (type !== undefined && subtypes.schemas[type] !== undefined) {
                subtypes.schemas[type].validate(additionalProperties, path);
            }
        }
    };
    return ObjectType;
}());
exports.ObjectType = ObjectType;
