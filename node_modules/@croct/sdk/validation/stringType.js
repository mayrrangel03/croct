"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringType = void 0;
var tslib_1 = require("tslib");
var schema_1 = require("./schema");
var violation_1 = require("./violation");
var FORMAT = {
    pointer: function pointer(value) {
        return /^(\.|([a-zA-Z_][a-zA-Z0-9_]*|\[[0-9]+])(\.[a-zA-Z_][a-zA-Z0-9_]*|\[[0-9]+])*)$/.test(value);
    },
    identifier: function identifier(value) {
        return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(value);
    },
    uuid: function uuid(value) {
        return /^[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/.test(value);
    },
    date: function date(value) {
        return /^(\d\d\d\d)-(\d\d)-(\d\d)$/.test(value);
    },
    url: function url(value) {
        try {
            // eslint-disable-next-line no-new
            new URL(value);
        }
        catch (_a) {
            return false;
        }
        return true;
    },
    'uri-reference': function uriReference(value) {
        try {
            // This simplistic approach covers the most common cases
            // without inflating the library with an RFC 3986-compliant parser.
            // eslint-disable-next-line no-new
            new URL(value, 'http://any.thing');
        }
        catch (_a) {
            return false;
        }
        return true;
    },
};
var StringType = /** @class */ (function () {
    function StringType(definition) {
        if (definition === void 0) { definition = {}; }
        var _a, _b, _c;
        this.definition = tslib_1.__assign(tslib_1.__assign({}, definition), { minLength: (_a = definition.minLength) !== null && _a !== void 0 ? _a : -1, maxLength: (_b = definition.maxLength) !== null && _b !== void 0 ? _b : -1, enumeration: (_c = definition.enumeration) !== null && _c !== void 0 ? _c : [] });
    }
    StringType.prototype.getTypes = function () {
        return ['string'];
    };
    StringType.prototype.isValidType = function (value) {
        return typeof value === 'string';
    };
    StringType.prototype.validate = function (value, path) {
        if (path === void 0) { path = []; }
        if (!this.isValidType(value)) {
            throw new schema_1.Violation("Expected value of type string at path '".concat((0, violation_1.formatPath)(path), "', actual ").concat((0, violation_1.describe)(value), "."), path, { type: 'string' });
        }
        var _a = this.definition, minLength = _a.minLength, maxLength = _a.maxLength;
        if (minLength >= 0 && minLength > value.length) {
            throw new schema_1.Violation("Expected ".concat(minLength === maxLength ? 'exactly' : 'at least', " ")
                + "".concat(minLength, " ").concat(minLength === 1 ? 'character' : 'characters', " ")
                + "at path '".concat((0, violation_1.formatPath)(path), "', actual ").concat(value.length, "."), path, { limit: minLength });
        }
        if (maxLength >= 0 && maxLength < value.length) {
            throw new schema_1.Violation("Expected ".concat(minLength === maxLength ? 'exactly' : 'at most', " ")
                + "".concat(maxLength, " ").concat(maxLength === 1 ? 'character' : 'characters', " ")
                + "at path '".concat((0, violation_1.formatPath)(path), "', actual ").concat(value.length, "."), path, { limit: maxLength });
        }
        var enumeration = this.definition.enumeration;
        if (enumeration.length > 0 && enumeration.indexOf(value) < 0) {
            throw new schema_1.Violation("Unexpected value at path '".concat((0, violation_1.formatPath)(path), "', expecting ")
                + "'".concat(enumeration.length === 1
                    ? enumeration[0]
                    : "".concat(enumeration.slice(0, -1).join('\', \''), "' or '").concat(enumeration.slice(-1)), "', ")
                + "found '".concat(value, "'."), path, { enumeration: enumeration });
        }
        var _b = this.definition, format = _b.format, pattern = _b.pattern;
        if (format !== undefined && !FORMAT[format](value)) {
            throw new schema_1.Violation("Invalid ".concat(format, " format at path '").concat((0, violation_1.formatPath)(path), "'."), path, { format: format });
        }
        if (pattern !== undefined && !pattern.test(value)) {
            throw new schema_1.Violation("Invalid format at path '".concat((0, violation_1.formatPath)(path), "'."), path, { pattern: pattern });
        }
    };
    return StringType;
}());
exports.StringType = StringType;
