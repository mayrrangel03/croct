var jsxRuntime = require('react/jsx-runtime');
var react = require('react');
var csrPlug = require('@croct/plug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var csrPlug__default = /*#__PURE__*/_interopDefaultLegacy(csrPlug);

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function isSsr() {
  return typeof window === 'undefined' || typeof window.document === 'undefined' || typeof window.document.createElement === 'undefined';
}
var croct = !isSsr() ? csrPlug__default["default"] : new Proxy(csrPlug__default["default"], {
  get(_, property) {
    switch (property) {
      case 'initialized':
        return false;

      case 'plug':
        return () => {// no-op
        };

      case 'unplug':
        return () => Promise.resolve();

      default:
        throw new Error("Property croct." + String(property) + " is not supported on server-side (SSR). Consider refactoring " + 'the logic as a side-effect (useEffect) or a client-side callback (onClick, onChange, etc).');
    }
  }

});

var _excluded$4 = ["children"];
var CroctContext = /*#__PURE__*/react.createContext(null);
CroctContext.displayName = 'CroctContext';
var CroctProvider = _ref => {
  var {
    children
  } = _ref,
      configuration = _objectWithoutPropertiesLoose(_ref, _excluded$4);

  var parent = react.useContext(CroctContext);

  if (parent !== null) {
    throw new Error('You cannot render <CroctProvider> inside another <CroctProvider>. ' + 'Croct should only be initialized once in the application.');
  }

  var context = react.useMemo(() => ({
    get plug() {
      if (!croct.initialized) {
        croct.plug(configuration);
      }

      return croct;
    }

  }), [configuration]);
  react.useEffect(() => {
    croct.plug(configuration);
    return () => {
      croct.unplug();
    };
  }, []);
  return jsxRuntime.jsx(CroctContext.Provider, {
    value: context,
    children: children
  });
};

class Cache {
  constructor(defaultExpiration) {
    this.cache = {};
    this.defaultExpiration = void 0;
    this.defaultExpiration = defaultExpiration;
  }

  load(configuration) {
    var {
      cacheKey,
      loader,
      fallback,
      expiration = this.defaultExpiration
    } = configuration;
    var cachedEntry = this.get(cacheKey);

    if (cachedEntry !== undefined) {
      if (cachedEntry.error !== undefined) {
        if (fallback !== undefined) {
          return fallback;
        }

        throw cachedEntry.error;
      }

      if (cachedEntry.result !== undefined) {
        return cachedEntry.result;
      }

      throw cachedEntry.promise;
    }

    var entry = {
      dispose: () => {
        if (entry.timeout !== undefined || expiration < 0) {
          return;
        }

        entry.timeout = window.setTimeout(() => {
          delete this.cache[cacheKey];
        }, expiration);
      },
      promise: loader().then(result => {
        entry.result = result;
        return result;
      }).catch(error => {
        entry.error = error;
      }).finally(() => {
        entry.dispose();
      })
    };
    this.cache[cacheKey] = entry;
    throw entry.promise;
  }

  get(cacheKey) {
    var entry = this.cache[cacheKey];

    if (entry === undefined) {
      return undefined;
    }

    if (entry.timeout !== undefined) {
      clearTimeout(entry.timeout);
      delete entry.timeout;
      entry.dispose();
    }

    return entry;
  }

}

var _excluded$3 = ["initial"];
var cache = new Cache(60 * 1000);
function useLoader(_ref) {
  var _cache$get;

  var {
    initial
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, _excluded$3);

  var loadedValue = (_cache$get = cache.get(options.cacheKey)) == null ? void 0 : _cache$get.result;
  var [value, setValue] = react.useState(loadedValue !== undefined ? loadedValue : initial);
  var [isUnmounted, setUnmounted] = react.useState(false);
  react.useEffect(() => {
    if (initial !== undefined) {
      try {
        setValue(cache.load(options));
      } catch (result) {
        if (result instanceof Promise) {
          result.then(resolvedValue => {
            if (!isUnmounted) {
              setValue(resolvedValue);
            }
          });
          return;
        }

        setValue(undefined);
        return;
      }
    }

    return () => {
      setUnmounted(true);
    };
  }, []);

  if (value === undefined) {
    return cache.load(options);
  }

  return value;
}

function useCroct() {
  var context = react.useContext(CroctContext);

  if (context === null) {
    throw new Error('useCroct() can only be used in the context of a <CroctProvider> component.');
  }

  return context.plug;
}

var _excluded$2 = ["cacheKey", "fallback", "initial", "expiration"];

function cleanEvaluationOptions(options) {
  var result = {};

  for (var [key, value] of Object.entries(options)) {
    if (value !== undefined) {
      result[key] = value;
    }
  }

  return result;
}

function useCsrEvaluation(expression, options) {
  var _options$attributes;

  if (options === void 0) {
    options = {};
  }

  var {
    cacheKey,
    fallback,
    initial,
    expiration
  } = options,
      evaluationOptions = _objectWithoutPropertiesLoose(options, _excluded$2);

  var croct = useCroct();
  return useLoader({
    cacheKey: "useEvaluation:" + (cacheKey != null ? cacheKey : '') + ":" + expression + ":" + JSON.stringify((_options$attributes = options.attributes) != null ? _options$attributes : ''),
    loader: () => croct.evaluate(expression, cleanEvaluationOptions(evaluationOptions)),
    initial: initial,
    fallback: fallback,
    expiration: expiration
  });
}

function useSsrEvaluation(_, _temp) {
  var {
    initial
  } = _temp === void 0 ? {} : _temp;

  if (initial === undefined) {
    throw new Error('The initial value is required for server-side rendering (SSR).');
  }

  return initial;
}

var useEvaluation = isSsr() ? useSsrEvaluation : useCsrEvaluation;

function useCsrContent(id, options) {
  if (options === void 0) {
    options = {};
  }

  var {
    fallback,
    initial,
    cacheKey,
    expiration
  } = options;
  var croct = useCroct();
  return useLoader({
    cacheKey: "useContent:" + (cacheKey != null ? cacheKey : '') + ":" + id,
    loader: () => croct.fetch(id).then(_ref => {
      var {
        payload
      } = _ref;
      return payload;
    }),
    initial: initial,
    fallback: fallback,
    expiration: expiration
  });
}

function useSsrContent(_, _temp) {
  var {
    initial
  } = _temp === void 0 ? {} : _temp;

  if (initial === undefined) {
    throw new Error('The initial value is required for server-side rendering (SSR).');
  }

  return initial;
}

var useContent = isSsr() ? useSsrContent : useCsrContent;

var _excluded$1 = ["expression", "children"];
function Personalization(props) {
  var {
    expression,
    children
  } = props,
      options = _objectWithoutPropertiesLoose(props, _excluded$1);

  var result = useEvaluation(expression, options);
  return jsxRuntime.jsx(react.Fragment, {
    children: children(result)
  });
}

var _excluded = ["id", "children"];
var Slot = props => {
  var {
    id,
    children
  } = props,
      options = _objectWithoutPropertiesLoose(props, _excluded);

  var data = useContent(id, options);
  return jsxRuntime.jsx(react.Fragment, {
    children: children(data)
  });
};

exports.CroctContext = CroctContext;
exports.CroctProvider = CroctProvider;
exports.Personalization = Personalization;
exports.Slot = Slot;
exports.useContent = useContent;
exports.useCroct = useCroct;
exports.useEvaluation = useEvaluation;
//# sourceMappingURL=index.js.map
