{"ast":null,"code":"var jsxRuntime = require('react/jsx-runtime');\n\nvar react = require('react');\n\nvar csrPlug = require('@croct/plug');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar csrPlug__default = /*#__PURE__*/_interopDefaultLegacy(csrPlug);\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction isSsr() {\n  return typeof window === 'undefined' || typeof window.document === 'undefined' || typeof window.document.createElement === 'undefined';\n}\n\nvar croct = !isSsr() ? csrPlug__default[\"default\"] : new Proxy(csrPlug__default[\"default\"], {\n  get(_, property) {\n    switch (property) {\n      case 'initialized':\n        return false;\n\n      case 'plug':\n        return () => {// no-op\n        };\n\n      case 'unplug':\n        return () => Promise.resolve();\n\n      default:\n        throw new Error(\"Property croct.\" + String(property) + \" is not supported on server-side (SSR). Consider refactoring \" + 'the logic as a side-effect (useEffect) or a client-side callback (onClick, onChange, etc).');\n    }\n  }\n\n});\nvar _excluded$4 = [\"children\"];\nvar CroctContext = /*#__PURE__*/react.createContext(null);\nCroctContext.displayName = 'CroctContext';\n\nvar CroctProvider = _ref => {\n  var {\n    children\n  } = _ref,\n      configuration = _objectWithoutPropertiesLoose(_ref, _excluded$4);\n\n  var parent = react.useContext(CroctContext);\n\n  if (parent !== null) {\n    throw new Error('You cannot render <CroctProvider> inside another <CroctProvider>. ' + 'Croct should only be initialized once in the application.');\n  }\n\n  var context = react.useMemo(() => ({\n    get plug() {\n      if (!croct.initialized) {\n        croct.plug(configuration);\n      }\n\n      return croct;\n    }\n\n  }), [configuration]);\n  react.useEffect(() => {\n    croct.plug(configuration);\n    return () => {\n      croct.unplug();\n    };\n  }, []);\n  return jsxRuntime.jsx(CroctContext.Provider, {\n    value: context,\n    children: children\n  });\n};\n\nclass Cache {\n  constructor(defaultExpiration) {\n    this.cache = {};\n    this.defaultExpiration = void 0;\n    this.defaultExpiration = defaultExpiration;\n  }\n\n  load(configuration) {\n    var {\n      cacheKey,\n      loader,\n      fallback,\n      expiration = this.defaultExpiration\n    } = configuration;\n    var cachedEntry = this.get(cacheKey);\n\n    if (cachedEntry !== undefined) {\n      if (cachedEntry.error !== undefined) {\n        if (fallback !== undefined) {\n          return fallback;\n        }\n\n        throw cachedEntry.error;\n      }\n\n      if (cachedEntry.result !== undefined) {\n        return cachedEntry.result;\n      }\n\n      throw cachedEntry.promise;\n    }\n\n    var entry = {\n      dispose: () => {\n        if (entry.timeout !== undefined || expiration < 0) {\n          return;\n        }\n\n        entry.timeout = window.setTimeout(() => {\n          delete this.cache[cacheKey];\n        }, expiration);\n      },\n      promise: loader().then(result => {\n        entry.result = result;\n        return result;\n      }).catch(error => {\n        entry.error = error;\n      }).finally(() => {\n        entry.dispose();\n      })\n    };\n    this.cache[cacheKey] = entry;\n    throw entry.promise;\n  }\n\n  get(cacheKey) {\n    var entry = this.cache[cacheKey];\n\n    if (entry === undefined) {\n      return undefined;\n    }\n\n    if (entry.timeout !== undefined) {\n      clearTimeout(entry.timeout);\n      delete entry.timeout;\n      entry.dispose();\n    }\n\n    return entry;\n  }\n\n}\n\nvar _excluded$3 = [\"initial\"];\nvar cache = new Cache(60 * 1000);\n\nfunction useLoader(_ref) {\n  var _cache$get;\n\n  var {\n    initial\n  } = _ref,\n      options = _objectWithoutPropertiesLoose(_ref, _excluded$3);\n\n  var loadedValue = (_cache$get = cache.get(options.cacheKey)) == null ? void 0 : _cache$get.result;\n  var [value, setValue] = react.useState(loadedValue !== undefined ? loadedValue : initial);\n  var [isUnmounted, setUnmounted] = react.useState(false);\n  react.useEffect(() => {\n    if (initial !== undefined) {\n      try {\n        setValue(cache.load(options));\n      } catch (result) {\n        if (result instanceof Promise) {\n          result.then(resolvedValue => {\n            if (!isUnmounted) {\n              setValue(resolvedValue);\n            }\n          });\n          return;\n        }\n\n        setValue(undefined);\n        return;\n      }\n    }\n\n    return () => {\n      setUnmounted(true);\n    };\n  }, []);\n\n  if (value === undefined) {\n    return cache.load(options);\n  }\n\n  return value;\n}\n\nfunction useCroct() {\n  var context = react.useContext(CroctContext);\n\n  if (context === null) {\n    throw new Error('useCroct() can only be used in the context of a <CroctProvider> component.');\n  }\n\n  return context.plug;\n}\n\nvar _excluded$2 = [\"cacheKey\", \"fallback\", \"initial\", \"expiration\"];\n\nfunction cleanEvaluationOptions(options) {\n  var result = {};\n\n  for (var [key, value] of Object.entries(options)) {\n    if (value !== undefined) {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\nfunction useCsrEvaluation(expression, options) {\n  var _options$attributes;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var {\n    cacheKey,\n    fallback,\n    initial,\n    expiration\n  } = options,\n      evaluationOptions = _objectWithoutPropertiesLoose(options, _excluded$2);\n\n  var croct = useCroct();\n  return useLoader({\n    cacheKey: \"useEvaluation:\" + (cacheKey != null ? cacheKey : '') + \":\" + expression + \":\" + JSON.stringify((_options$attributes = options.attributes) != null ? _options$attributes : ''),\n    loader: () => croct.evaluate(expression, cleanEvaluationOptions(evaluationOptions)),\n    initial: initial,\n    fallback: fallback,\n    expiration: expiration\n  });\n}\n\nfunction useSsrEvaluation(_, _temp) {\n  var {\n    initial\n  } = _temp === void 0 ? {} : _temp;\n\n  if (initial === undefined) {\n    throw new Error('The initial value is required for server-side rendering (SSR).');\n  }\n\n  return initial;\n}\n\nvar useEvaluation = isSsr() ? useSsrEvaluation : useCsrEvaluation;\n\nfunction useCsrContent(id, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var {\n    fallback,\n    initial,\n    cacheKey,\n    expiration\n  } = options;\n  var croct = useCroct();\n  return useLoader({\n    cacheKey: \"useContent:\" + (cacheKey != null ? cacheKey : '') + \":\" + id,\n    loader: () => croct.fetch(id).then(_ref => {\n      var {\n        payload\n      } = _ref;\n      return payload;\n    }),\n    initial: initial,\n    fallback: fallback,\n    expiration: expiration\n  });\n}\n\nfunction useSsrContent(_, _temp) {\n  var {\n    initial\n  } = _temp === void 0 ? {} : _temp;\n\n  if (initial === undefined) {\n    throw new Error('The initial value is required for server-side rendering (SSR).');\n  }\n\n  return initial;\n}\n\nvar useContent = isSsr() ? useSsrContent : useCsrContent;\nvar _excluded$1 = [\"expression\", \"children\"];\n\nfunction Personalization(props) {\n  var {\n    expression,\n    children\n  } = props,\n      options = _objectWithoutPropertiesLoose(props, _excluded$1);\n\n  var result = useEvaluation(expression, options);\n  return jsxRuntime.jsx(react.Fragment, {\n    children: children(result)\n  });\n}\n\nvar _excluded = [\"id\", \"children\"];\n\nvar Slot = props => {\n  var {\n    id,\n    children\n  } = props,\n      options = _objectWithoutPropertiesLoose(props, _excluded);\n\n  var data = useContent(id, options);\n  return jsxRuntime.jsx(react.Fragment, {\n    children: children(data)\n  });\n};\n\nexports.CroctContext = CroctContext;\nexports.CroctProvider = CroctProvider;\nexports.Personalization = Personalization;\nexports.Slot = Slot;\nexports.useContent = useContent;\nexports.useCroct = useCroct;\nexports.useEvaluation = useEvaluation;","map":{"version":3,"mappings":"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","names":["isSsr","window","document","createElement","croct","csrPlug","Proxy","get","_","property","Promise","resolve","Error","String","CroctContext","createContext","displayName","CroctProvider","_ref","children","configuration","parent","useContext","context","useMemo","plug","initialized","useEffect","unplug","_jsx","Provider","value","Cache","constructor","defaultExpiration","cache","load","cacheKey","loader","fallback","expiration","cachedEntry","undefined","error","result","promise","entry","dispose","timeout","setTimeout","then","catch","finally","clearTimeout","useLoader","initial","options","loadedValue","_cache$get","setValue","useState","isUnmounted","setUnmounted","resolvedValue","useCroct","cleanEvaluationOptions","key","Object","entries","useCsrEvaluation","expression","evaluationOptions","JSON","stringify","attributes","_options$attributes","evaluate","useSsrEvaluation","_temp","useEvaluation","useCsrContent","id","fetch","payload","useSsrContent","useContent","Personalization","props","Fragment","Slot","data"],"sources":["C:\\Users\\User\\croct\\node_modules\\@croct\\src\\ssr-polyfills.ts","C:\\Users\\User\\croct\\node_modules\\@croct\\src\\CroctProvider.tsx","C:\\Users\\User\\croct\\node_modules\\@croct\\src\\hooks\\Cache.ts","C:\\Users\\User\\croct\\node_modules\\@croct\\src\\hooks\\useLoader.ts","C:\\Users\\User\\croct\\node_modules\\@croct\\src\\hooks\\useCroct.ts","C:\\Users\\User\\croct\\node_modules\\@croct\\src\\hooks\\useEvaluation.ts","C:\\Users\\User\\croct\\node_modules\\@croct\\src\\hooks\\useContent.ts","C:\\Users\\User\\croct\\node_modules\\@croct\\src\\components\\Personalization\\index.tsx","C:\\Users\\User\\croct\\node_modules\\@croct\\src\\components\\Slot\\index.tsx"],"sourcesContent":["import csrPlug, {Plug} from '@croct/plug';\n\nexport function isSsr(): boolean {\n    return typeof window === 'undefined'\n        || typeof window.document === 'undefined'\n        || typeof window.document.createElement === 'undefined';\n}\n\nexport const croct: Plug = !isSsr() ? csrPlug : new Proxy(csrPlug, {\n    get(_, property: keyof Plug) {\n        switch (property) {\n            case 'initialized':\n                return false;\n\n            case 'plug':\n                return () => {\n                    // no-op\n                };\n\n            case 'unplug':\n                return () => Promise.resolve();\n\n            default:\n                throw new Error(\n                    `Property croct.${String(property)} is not supported on server-side (SSR). Consider refactoring `\n                    + 'the logic as a side-effect (useEffect) or a client-side callback (onClick, onChange, etc).',\n                );\n        }\n    },\n});\n\n","import {createContext, FunctionComponent, PropsWithChildren, ReactElement, useContext, useEffect, useMemo} from 'react';\nimport {Configuration, Plug} from '@croct/plug';\nimport {croct} from './ssr-polyfills';\n\nexport type CroctProviderProps = PropsWithChildren<Configuration & Required<Pick<Configuration, 'appId'>>>;\n\nexport const CroctContext = createContext<{plug: Plug}|null>(null);\nCroctContext.displayName = 'CroctContext';\n\nexport const CroctProvider: FunctionComponent<CroctProviderProps> = ({children, ...configuration}): ReactElement => {\n    const parent = useContext(CroctContext);\n\n    if (parent !== null) {\n        throw new Error(\n            'You cannot render <CroctProvider> inside another <CroctProvider>. '\n            + 'Croct should only be initialized once in the application.',\n        );\n    }\n\n    const context = useMemo(() => ({\n        get plug() {\n            if (!croct.initialized) {\n                croct.plug(configuration);\n            }\n\n            return croct;\n        },\n    }), [configuration]);\n\n    useEffect(() => {\n        croct.plug(configuration);\n\n        return () => {\n            croct.unplug();\n        };\n    }, []);\n\n    return (\n        <CroctContext.Provider value={context}>\n            {children}\n        </CroctContext.Provider>\n    );\n};\n","export type EntryLoader<R> = (...args: any) => Promise<R>;\n\nexport type EntryOptions<R> = {\n    cacheKey: string,\n    loader: EntryLoader<R>,\n    fallback?: R,\n    expiration?: number,\n};\n\ntype Entry<R = any> = {\n    promise: Promise<any>,\n    result?: R,\n    dispose: () => void,\n    timeout?: number,\n    error?: any,\n};\n\nexport class Cache {\n    private readonly cache: Record<string, Entry> = {};\n\n    private readonly defaultExpiration: number;\n\n    public constructor(defaultExpiration: number) {\n        this.defaultExpiration = defaultExpiration;\n    }\n\n    public load<R>(configuration: EntryOptions<R>): R {\n        const {cacheKey, loader, fallback, expiration = this.defaultExpiration} = configuration;\n\n        const cachedEntry = this.get<R>(cacheKey);\n\n        if (cachedEntry !== undefined) {\n            if (cachedEntry.error !== undefined) {\n                if (fallback !== undefined) {\n                    return fallback;\n                }\n\n                throw cachedEntry.error;\n            }\n\n            if (cachedEntry.result !== undefined) {\n                return cachedEntry.result;\n            }\n\n            throw cachedEntry.promise;\n        }\n\n        const entry: Entry<R> = {\n            dispose: () => {\n                if (entry.timeout !== undefined || expiration < 0) {\n                    return;\n                }\n\n                entry.timeout = window.setTimeout(\n                    (): void => {\n                        delete this.cache[cacheKey];\n                    },\n                    expiration,\n                );\n            },\n            promise: loader()\n                .then((result): R => {\n                    entry.result = result;\n\n                    return result;\n                })\n                .catch(error => {\n                    entry.error = error;\n                })\n                .finally(() => {\n                    entry.dispose();\n                }),\n        };\n\n        this.cache[cacheKey] = entry;\n\n        throw entry.promise;\n    }\n\n    public get<R>(cacheKey: string): Entry<R>|undefined {\n        const entry = this.cache[cacheKey];\n\n        if (entry === undefined) {\n            return undefined;\n        }\n\n        if (entry.timeout !== undefined) {\n            clearTimeout(entry.timeout);\n\n            delete entry.timeout;\n\n            entry.dispose();\n        }\n\n        return entry;\n    }\n}\n","import {useEffect, useState} from 'react';\nimport {Cache, EntryOptions} from './Cache';\n\nconst cache = new Cache(60 * 1000);\n\nexport type CacheOptions<R> = EntryOptions<R> & {\n    initial?: R,\n};\n\nexport function useLoader<R>({initial, ...options}: CacheOptions<R>): R {\n    const loadedValue: R|undefined = cache.get<R>(options.cacheKey)?.result;\n    const [value, setValue] = useState(loadedValue !== undefined ? loadedValue : initial);\n    const [isUnmounted, setUnmounted] = useState(false);\n\n    useEffect(\n        () => {\n            if (initial !== undefined) {\n                try {\n                    setValue(cache.load(options));\n                } catch (result: unknown) {\n                    if (result instanceof Promise) {\n                        result.then((resolvedValue: R) => {\n                            if (!isUnmounted) {\n                                setValue(resolvedValue);\n                            }\n                        });\n\n                        return;\n                    }\n\n                    setValue(undefined);\n\n                    return;\n                }\n            }\n\n            return () => {\n                setUnmounted(true);\n            };\n        },\n        [],\n    );\n\n    if (value === undefined) {\n        return cache.load(options);\n    }\n\n    return value;\n}\n","import {Plug} from '@croct/plug';\nimport {useContext} from 'react';\nimport {CroctContext} from '../CroctProvider';\n\nexport function useCroct(): Plug {\n    const context = useContext(CroctContext);\n\n    if (context === null) {\n        throw new Error('useCroct() can only be used in the context of a <CroctProvider> component.');\n    }\n\n    return context.plug;\n}\n","import {JsonValue} from '@croct/plug/sdk/json';\nimport {EvaluationOptions} from '@croct/sdk/facade/evaluatorFacade';\nimport {useLoader} from './useLoader';\nimport {useCroct} from './useCroct';\nimport {isSsr} from '../ssr-polyfills';\n\nfunction cleanEvaluationOptions(options: EvaluationOptions): EvaluationOptions {\n    const result: EvaluationOptions = {};\n\n    for (const [key, value] of Object.entries(options)) {\n        if (value !== undefined) {\n            result[key] = value;\n        }\n    }\n\n    return result;\n}\n\nexport type UseEvaluationOptions<I, F> = EvaluationOptions & {\n    initial?: I,\n    fallback?: F,\n    cacheKey?: string,\n    expiration?: number,\n};\n\ntype UseEvaluationHook = <T extends JsonValue, I = T, F = T>(\n    expression: string,\n    options?: UseEvaluationOptions<I, F>,\n) => T | I | F;\n\nfunction useCsrEvaluation<T = JsonValue, I = T, F = T>(\n    expression: string,\n    options: UseEvaluationOptions<I, F> = {},\n): T | I | F {\n    const {cacheKey, fallback, initial, expiration, ...evaluationOptions} = options;\n    const croct = useCroct();\n\n    return useLoader<T | I | F>({\n        cacheKey: `useEvaluation:${cacheKey ?? ''}:${expression}:${JSON.stringify(options.attributes ?? '')}`,\n        loader: () => croct.evaluate<T & JsonValue>(expression, cleanEvaluationOptions(evaluationOptions)),\n        initial: initial,\n        fallback: fallback,\n        expiration: expiration,\n    });\n}\n\nfunction useSsrEvaluation<T = JsonValue, I = T, F = T>(\n    _: string,\n    {initial}: UseEvaluationOptions<I, F> = {},\n): T | I | F {\n    if (initial === undefined) {\n        throw new Error('The initial value is required for server-side rendering (SSR).');\n    }\n\n    return initial;\n}\n\nexport const useEvaluation: UseEvaluationHook = isSsr() ? useSsrEvaluation : useCsrEvaluation;\n","import {SlotContent, SlotId, SlotMap} from '@croct/plug/fetch';\nimport {NullableJsonObject} from '@croct/plug/sdk/json';\nimport {useLoader} from './useLoader';\nimport {useCroct} from './useCroct';\nimport {isSsr} from '../ssr-polyfills';\n\nexport type UseContentOptions<I, F> = {\n    fallback?: F,\n    initial?: I,\n    cacheKey?: string,\n    expiration?: number,\n};\n\nfunction useCsrContent<I, F>(id: SlotId, options: UseContentOptions<I, F> = {}): SlotContent<SlotId> | I | F {\n    const {fallback, initial, cacheKey, expiration} = options;\n    const croct = useCroct();\n\n    return useLoader({\n        cacheKey: `useContent:${cacheKey ?? ''}:${id}`,\n        loader: () => croct.fetch<SlotContent<SlotId>>(id).then(({payload}) => payload),\n        initial: initial,\n        fallback: fallback,\n        expiration: expiration,\n    });\n}\n\nfunction useSsrContent<I, F>(_: SlotId, {initial}: UseContentOptions<I, F> = {}): SlotContent<SlotId> | I | F {\n    if (initial === undefined) {\n        throw new Error('The initial value is required for server-side rendering (SSR).');\n    }\n\n    return initial;\n}\n\ntype UseContentHook = {\n    <P extends NullableJsonObject, I = P, F = P>(\n        id: keyof SlotMap extends never ? string : never,\n        options?: UseContentOptions<I, F>\n    ): P | I | F,\n\n    <S extends keyof SlotMap>(\n        id: S,\n        options?: UseContentOptions<never, never>\n    ): SlotContent<S>,\n\n    <I, S extends keyof SlotMap>(\n        id: S,\n        options?: UseContentOptions<I, never>\n    ): SlotContent<S> | I,\n\n    <F, S extends keyof SlotMap>(\n        id: S,\n        options?: UseContentOptions<never, F>\n    ): SlotContent<S> | F,\n\n    <I, F, S extends keyof SlotMap>(\n        id: S,\n        options?: UseContentOptions<I, F>\n    ): SlotContent<S> | I | F,\n};\n\nexport const useContent: UseContentHook = isSsr() ? useSsrContent : useCsrContent;\n","import {ReactChild, ReactElement, Fragment} from 'react';\nimport {JsonValue} from '@croct/plug/sdk/json';\nimport {UseEvaluationOptions, useEvaluation} from '../../hooks';\n\ntype Renderer<T> = (result: T) => ReactChild;\n\nexport type PersonalizationProps<T extends JsonValue = JsonValue, I = T, F = T> = UseEvaluationOptions<I, F> & {\n    expression: string,\n    children: Renderer<T | I | F>,\n};\n\nexport function Personalization<T extends JsonValue, I, F>(\n    props:\n        Extract<T | I | F, JsonValue> extends never\n            ? PersonalizationProps\n            : PersonalizationProps<T, I, F>,\n): ReactElement;\n\nexport function Personalization<I, F>(props: PersonalizationProps<JsonValue, I, F>): ReactElement {\n    const {expression, children, ...options} = props;\n    const result = useEvaluation(expression, options);\n\n    return (<Fragment>{children(result)}</Fragment>);\n}\n","import {Fragment, ReactChild, ReactElement} from 'react';\nimport {SlotContent, SlotId, SlotMap} from '@croct/plug/fetch';\nimport {NullableJsonObject} from '@croct/plug/sdk/json';\nimport {useContent, UseContentOptions} from '../../hooks';\n\ntype Renderer<P> = (props: P) => ReactChild;\n\nexport type SlotProps<P, I = P, F = P, S extends SlotId = SlotId> = UseContentOptions<I, F> & {\n    id: S,\n    children: Renderer<P | I | F>,\n};\n\ntype SlotComponent = {\n    <P, I, F>(\n        props:\n            Extract<P | I | F, NullableJsonObject> extends never\n                ? SlotProps<NullableJsonObject, never, never, keyof SlotMap extends never ? string : never>\n                : SlotProps<P, I, F, keyof SlotMap extends never ? string : never>\n    ): ReactElement,\n\n    <S extends keyof SlotMap>(props: SlotProps<SlotContent<S>, never, never, S>): ReactElement,\n\n    <I, S extends keyof SlotMap>(props: SlotProps<SlotContent<S>, I, never, S>): ReactElement,\n\n    <F, S extends keyof SlotMap>(props: SlotProps<SlotContent<S>, never, F, S>): ReactElement,\n\n    <I, F, S extends keyof SlotMap>(props: SlotProps<SlotContent<S>, I, F, S>): ReactElement,\n\n    (props: SlotProps<void, void, void>): ReactElement,\n};\n\nexport const Slot: SlotComponent = <I, F>(props: SlotProps<NullableJsonObject, I, F>): ReactElement => {\n    const {id, children, ...options} = props;\n    const data: SlotContent<SlotId> | I | F = useContent(id, options);\n\n    return <Fragment>{children(data)}</Fragment>;\n};\n"]},"metadata":{},"sourceType":"script"}